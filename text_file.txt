Here's a README file tailored for your AutoBI project, taking inspiration from the structure of the VSwarm README:
 
 
---
 
<div align="center"><img alt="AutoBI" height="200px" src="./img/logo.png"><h1>AutoBI</h1><p><b>Low code tool to convert text into SQL queries and interact with various databases using LLMs</b></p></div>Table of Contents
 
What is AutoBI?
 
Use Cases
 
Highlights
 
How to Get Started
 
Generate Secret Keys
 
Deploy AutoBI Locally with Docker
 
Deploy AutoBI on a Remote Server
 
 
Guides and Concepts
 
Sequential vs Hierarchical Workflows
 
Creating a Skill using Skill Definitions
 
Writing a Custom Skill using LangChain
 
Retrieval Augmented Generation (RAG)
 
Customizing Embedding Models
 
 
Contribution
 
License
 
 
What is AutoBI?
 
AutoBI is a robust tool that leverages Large Language Models (LLMs) to transform natural language into SQL queries, allowing users to query data from multiple databases with ease. Using LangChain, AutoBI provides a seamless way to interact with PostgreSQL, Redis, and other database systems through an intuitive interface, empowering businesses to extract actionable insights without needing extensive SQL knowledge.
 
Use Cases
 
AutoBI can be applied in a variety of domains, including but not limited to:
 
Business Intelligence: AutoBI enables business users to generate insights from various databases by converting natural language questions into SQL queries.
 
Data Exploration: Analysts can explore datasets in different databases without having to write complex SQL queries.
 
Customer Support: AutoBI can help support teams access data by asking natural language queries, making customer service more efficient.
 
Ad-hoc Reporting: AutoBI allows quick generation of reports by querying multiple tables across databases.
 
 
Highlights
 
Persistent conversations: AutoBI saves and maintains conversation histories, enabling continuous and evolving data analysis.
 
Observability: Monitor and track query performance and outputs in real-time, ensuring efficient data retrieval.
 
Tool Calling: AutoBI integrates external tools and APIs, expanding its capabilities.
 
Retrieval Augmented Generation: AutoBI augments your LLM's reasoning with your internal knowledge base.
 
Human-In-The-Loop: For critical tasks, AutoBI enables human approval before query execution.
 
Open Source Models: Use open-source LLM models like GPT, Gemini, and others.
 
Easy Deployment: Deploy AutoBI with Docker for seamless and scalable operations.
 
Multi-Tenancy: Manage and support multiple users and teams with ease.
 
 
How to Get Started
 
Generate Secret Keys
 
You need to generate secret keys to secure your AutoBI instance. Run the following command to generate a secret key:
 
python -c "import secrets; print(secrets.token_urlsafe(32))"
 
Copy and use the generated key for SECRET_KEY, POSTGRES_PASSWORD, etc. You can run the command multiple times to generate additional keys.
 
Deploy AutoBI Locally with Docker
 
To deploy AutoBI on your local machine using Docker, follow the local deployment guide.
 
Deploy AutoBI on a Remote Server
 
For deploying AutoBI on a remote server, refer to the remote deployment guide.
 
Guides and Concepts
 
Sequential vs Hierarchical Workflows
 
AutoBI supports both sequential and hierarchical workflows for query execution. In a sequential workflow, queries are executed one after another. In a hierarchical workflow, complex queries are broken down and delegated to different agents or sub-teams for execution.
 
Creating a Skill Using Skill Definitions
 
You can create custom skills that allow agents to interact with external APIs, fetch data, or execute queries. Simply provide a skill definition in the 'Skills' tab and configure the parameters.
 
Writing a Custom Skill using LangChain
 
For more advanced capabilities, you can write custom skills using LangChain. Refer to the LangChain documentation for guidance.
 
Retrieval Augmented Generation (RAG)
 
RAG enables AutoBI to reason with additional private data uploaded into its knowledge base. You can select specific datasets for agents to reason with, making their responses more specialized.
 
Customizing Embedding Models
 
By default, AutoBI uses BAAI/bge-small-en-v1.5. You can customize the embedding model by editing the DENSE_EMBEDDING_MODEL in the environment configuration. Refer to the list of supported models.
 
Contribution
 
AutoBI is an open-source project, and we welcome contributions! To get started, check out our contribution guide.
 
Some ways to contribute:
 
Report bugs and issues
 
Enhance our documentation
 
Suggest or contribute new features
 
 
License
 
AutoBI is licensed under the MIT license. Check the license file for more details.
 
 
---
 
This README provides a clear and structured overview of the AutoBI project, similar to the VSwarm README, but tailored to your specific project. Let me know if you need further adjustments!







organisation backend 
app.py->

from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy.orm import Session
from models import Organization, OrganizationCreate
from db import get_db, Base, engine

app = FastAPI()

# Initialize the database tables
Base.metadata.create_all(bind=engine)

@app.get("/organizations")
def get_organizations(db: Session = Depends(get_db)):
    organizations = db.query(Organization).all()
    return organizations

@app.post("/organizations", status_code=201)
def add_organization(organization: OrganizationCreate, db: Session = Depends(get_db)):
    new_org = Organization(name=organization.name, description=organization.description)
    db.add(new_org)
    db.commit()
    db.refresh(new_org)
    return new_org

@app.delete("/organizations/{org_id}", status_code=204)
def delete_organization(org_id: int, db: Session = Depends(get_db)):
    org = db.query(Organization).filter(Organization.id == org_id).first()
    if not org:
        raise HTTPException(status_code=404, detail="Organization not found")
    db.delete(org)
    db.commit()
    return {"detail": "Organization deleted successfully"}



models.py->
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from pydantic import BaseModel

Base = declarative_base()

class Organization(Base):
    __tablename__ = "organizations"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(String(500), nullable=False)

class OrganizationCreate(BaseModel):
    name: str
    description: str



db.py->
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./organizations.db"

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Dependency for FastAPI routes
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()




db_init->

from db import engine, Base

Base.metadata.create_all(bind=engine)
print("Database initialized successfully.")


requirements.txt->
fastapi==0.95.2
uvicorn==0.23.1
SQLAlchemy==1.4.49
pydantic==1.10.7



























app.py

from fastapi import FastAPI, HTTPException, Depends
from sqlalchemy.orm import Session
from models import Organization, OrganizationCreate, User
from db import get_db, Base, engine


app = FastAPI()

# Ensure the database tables are created
print("Creating tables...")
Base.metadata.create_all(bind=engine)
print("Tables created successfully!")


@app.get("/organizations")
def get_organizations(db: Session = Depends(get_db)):
    organizations = db.query(Organization).all()
    return organizations

@app.post("/organizations", status_code=201)
def add_organization(organization: OrganizationCreate, db: Session = Depends(get_db)):
    new_org = Organization(name=organization.name, description=organization.description)
    db.add(new_org)
    db.commit()
    db.refresh(new_org)
    return new_org

@app.delete("/organizations/{org_id}", status_code=204)
def delete_organization(org_id: int, db: Session = Depends(get_db)):
    org = db.query(Organization).filter(Organization.id == org_id).first()
    if not org:
        raise HTTPException(status_code=404, detail="Organization not found")
    db.delete(org)
    db.commit()
    return {"detail": "Organization deleted successfully"}

@app.put("/organizations/{org_id}", status_code=200)
def update_organization(org_id: int, organization: OrganizationCreate, db: Session = Depends(get_db)):
    org = db.query(Organization).filter(Organization.id == org_id).first()
    if not org:
        raise HTTPException(status_code=404, detail="Organization not found")
    org.name = organization.name
    org.description = organization.description
    db.commit()
    return org

























# from fastapi import FastAPI
# from sqlalchemy import create_engine
# from sqlalchemy.ext.declarative import declarative_base
# from sqlalchemy.orm import sessionmaker
# from models import Base  # Assuming your models are defined in models.py

# SQLALCHEMY_DATABASE_URL = "sqlite:///./organizations.db"

# engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
# SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# # Create the tables
# Base.metadata.create_all(bind=engine)

# app = FastAPI()

# # Dependency
# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()





models.py

from sqlalchemy import Column, Integer, String, Boolean
from sqlalchemy.ext.declarative import declarative_base
from pydantic import BaseModel

Base = declarative_base()

class Organization(Base):
    __tablename__ = "table_org"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    description = Column(String(500), nullable=False)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_superadmin = Column(Boolean, default=False)

class OrganizationCreate(BaseModel):
    name: str
    description: str



db.py


import os
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from models import Base  # Assuming your models are defined in models.py

SQLALCHEMY_DATABASE_URL = "sqlite:///./organizations.db"
print(f"Database path: {os.path.abspath('organizations.db')}")

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Dependency for FastAPI routes
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()









C:\Users\trish1u\Desktop\my>uvicorn app:app --reload
INFO:     Will watch for changes in these directories: ['C:\\Users\\trish1u\\Desktop\\my']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [7200] using StatReload
ERROR:    Error loading ASGI app. Could not import module "app".





C:\Users\trish1u\Desktop\my>sqlite3 organizations.db
'sqlite3' is not recognized as an internal or external command,
operable program or batch file.
